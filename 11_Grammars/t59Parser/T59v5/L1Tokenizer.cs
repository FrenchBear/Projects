// Level 1 tokenizer
//
// Transform a stream of lexer tokens into L1Tokens:
// - Ignore WS
// - Group successive InvalidChar into InvalidToken
// - Transform all I_xx into L1Instruction with attributes
// - Add a property SyntaxCategory, initialized at a reasonable default from lexer perspective but maigh change later
//
// 2025-11-22   PV

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Antlr4.Runtime;

namespace T59v5;

abstract record L1Token
{
    public List<IToken> Tokens { get; set; }
    public SyntaxCategory Cat { get; set; }

    public virtual string AsString()
    {
        var s = string.Join(", ", Tokens.Select(t => $"{t.Line}:{t.Column} {t.Text}"));
        var c = Cat.ToString();
        return $"{this.GetType().Name,-15}: {s,-15} {c}";
    }
}

record L1Eof: L1Token { }
record L1ProgramSeparator: L1Token { }
record L1LineComment: L1Token { }
record L1InvalidToken: L1Token { }
record L1Instruction: L1Token
{
    public L1Inst Inst { get; set; }

    public override string AsString()
    {
        var s = string.Join(", ", Tokens.Select(t => $"{t.Line}:{t.Column} {t.Text}"));
        var c = Cat.ToString();
        return $"{this.GetType().Name,-15}: {s,-15} {c,-15} {Inst}";
    }

}
record L1D1: L1Token { }
record L1D2: L1Token { }
record L1A3: L1Token { }
record L1Num: L1Token { }
record L1Tag: L1Token { }
record L1Colon: L1Token { }

record L1Inst
{
    public int op { get; set; }         // Opcode
    public string m { get; set; }       // Mnemonic (canonical version)
    public string s { get; set; }       // Syntax
    public bool i { get; set; }         // Invertible
    public int mop { get; set; }        // Indirect merged opcode
}


internal class L1Tokenizer
{
    private Vocab lexer;

    static Dictionary<int, L1Inst> TInst = new();

    static L1Tokenizer()
    {
        // Build dictionary of instructions attributes, generated by Excel
        // Doesn't include extra instructions I123_e_power_x and I128_10_power_x, we'll see later if they need to be included or managed directly in parser code
        // Maybe simplify sonsidering s="a" is the default ?
        TInst.Add(Vocab.I10_e_prime, new L1Inst { op = 10, m = "E'", s = "a" });
        TInst.Add(Vocab.I11_a, new L1Inst { op = 11, m = "A", s = "a" });
        TInst.Add(Vocab.I12_b, new L1Inst { op = 12, m = "B", s = "a" });
        TInst.Add(Vocab.I13_c, new L1Inst { op = 13, m = "C", s = "a" });
        TInst.Add(Vocab.I14_d, new L1Inst { op = 14, m = "D", s = "a" });
        TInst.Add(Vocab.I15_e, new L1Inst { op = 15, m = "E", s = "a" });
        TInst.Add(Vocab.I16_a_prime, new L1Inst { op = 16, m = "A'", s = "a" });
        TInst.Add(Vocab.I17_b_prime, new L1Inst { op = 17, m = "B'", s = "a" });
        TInst.Add(Vocab.I18_c_prime, new L1Inst { op = 18, m = "C'", s = "a" });
        TInst.Add(Vocab.I19_d_prime, new L1Inst { op = 19, m = "D'", s = "a" });
        TInst.Add(Vocab.I20_2nd_clear, new L1Inst { op = 20, m = "CLR'", s = "a" });

        TInst.Add(Vocab.I22_invert, new L1Inst { op = 22, m = "INV", s = "a" });
        TInst.Add(Vocab.I23_ln, new L1Inst { op = 23, m = "lnx", s = "a", i = true });
        TInst.Add(Vocab.I24_correct_entry, new L1Inst { op = 24, m = "CE", s = "a" });
        TInst.Add(Vocab.I25_clear, new L1Inst { op = 25, m = "CLR", s = "a" });

        TInst.Add(Vocab.I27_2nd_invert, new L1Inst { op = 27, m = "INV'", s = "a" });
        TInst.Add(Vocab.I28_log, new L1Inst { op = 28, m = "log", s = "a", i = true });
        TInst.Add(Vocab.I29_clear_program, new L1Inst { op = 29, m = "CP", s = "a" });
        TInst.Add(Vocab.I30_tan, new L1Inst { op = 30, m = "tan", s = "a", i = true });

        TInst.Add(Vocab.I32_exchange_x_and_t, new L1Inst { op = 32, m = "x⇄t", s = "a" });
        TInst.Add(Vocab.I33_square, new L1Inst { op = 33, m = "x²", s = "a" });
        TInst.Add(Vocab.I34_square_root, new L1Inst { op = 34, m = "√", s = "a" });
        TInst.Add(Vocab.I35_reciprocal, new L1Inst { op = 35, m = "1/x", s = "a" });
        TInst.Add(Vocab.I36_program, new L1Inst { op = 36, m = "Pgm", s = "di", mop = 62 });
        TInst.Add(Vocab.I37_polar_to_rectangular, new L1Inst { op = 37, m = "P->R", s = "a", i = true });
        TInst.Add(Vocab.I38_sin, new L1Inst { op = 38, m = "sin", s = "a", i = true });
        TInst.Add(Vocab.I39_cos, new L1Inst { op = 39, m = "cos", s = "a", i = true });
        TInst.Add(Vocab.I40_indirect, new L1Inst { op = 40, m = "Ind", s = "p" });

        TInst.Add(Vocab.I42_store, new L1Inst { op = 42, m = "STO", s = "di", mop = 72 });
        TInst.Add(Vocab.I43_recall, new L1Inst { op = 43, m = "RCL", s = "di", mop = 73 });
        TInst.Add(Vocab.I44_sum, new L1Inst { op = 44, m = "SUM", s = "di", i = true, mop = 74 });
        TInst.Add(Vocab.I45_power, new L1Inst { op = 45, m = "yˣ", s = "a", i = true });

        TInst.Add(Vocab.I47_clear_memory, new L1Inst { op = 47, m = "CMs", s = "a" });
        TInst.Add(Vocab.I48_exchange, new L1Inst { op = 48, m = "Exc", s = "di", mop = 63 });
        TInst.Add(Vocab.I49_product, new L1Inst { op = 49, m = "Prd", s = "di", i = true, mop = 64 });
        TInst.Add(Vocab.I50_absolute, new L1Inst { op = 50, m = "", s = "a" });

        TInst.Add(Vocab.I52_exponent, new L1Inst { op = 52, m = "EE", s = "a", i = true });
        TInst.Add(Vocab.I53_left_parenthesis, new L1Inst { op = 53, m = "(", s = "a" });
        TInst.Add(Vocab.I54_right_parenthesis, new L1Inst { op = 54, m = ")", s = "a" });
        TInst.Add(Vocab.I55_divide, new L1Inst { op = 55, m = "/", s = "a" });

        TInst.Add(Vocab.I57_engineering, new L1Inst { op = 57, m = "Eng", s = "a", i = true });
        TInst.Add(Vocab.I58_fix, new L1Inst { op = 58, m = "Fix", s = "di", i = true });
        TInst.Add(Vocab.I59_integer, new L1Inst { op = 59, m = "Int", s = "a", i = true });
        TInst.Add(Vocab.I60_degrees, new L1Inst { op = 60, m = "Deg", s = "a" });
        TInst.Add(Vocab.I61_goto, new L1Inst { op = 61, m = "GTO", s = "b", mop = 83 });
        TInst.Add(Vocab.I62_program_indirect, new L1Inst { op = 62, m = "PG*", s = "i" });
        TInst.Add(Vocab.I63_exchange_indirect, new L1Inst { op = 63, m = "EX*", s = "i" });
        TInst.Add(Vocab.I64_product_indirect, new L1Inst { op = 64, m = "PD*", s = "i", i = true });
        TInst.Add(Vocab.I65_multiply, new L1Inst { op = 65, m = "*", s = "a" });
        TInst.Add(Vocab.I66_pause, new L1Inst { op = 66, m = "Pause", s = "a" });
        TInst.Add(Vocab.I67_x_equals_t, new L1Inst { op = 67, m = "x=t", s = "b", i = true });
        TInst.Add(Vocab.I68_nop, new L1Inst { op = 68, m = "Nop", s = "a" });
        TInst.Add(Vocab.I69_operation, new L1Inst { op = 69, m = "Op", s = "di", mop = 84 });
        TInst.Add(Vocab.I70_radians, new L1Inst { op = 70, m = "Rad", s = "a" });
        TInst.Add(Vocab.I71_subroutine, new L1Inst { op = 71, m = "SBR", s = "b", i = true });
        TInst.Add(Vocab.I72_store_indirect, new L1Inst { op = 72, m = "ST*", s = "i" });
        TInst.Add(Vocab.I73_recall_indirect, new L1Inst { op = 73, m = "RC*", s = "i" });
        TInst.Add(Vocab.I74_sum_indirect, new L1Inst { op = 74, m = "SM*", s = "i", i = true });
        TInst.Add(Vocab.I75_subtract, new L1Inst { op = 75, m = "-", s = "a" });
        TInst.Add(Vocab.I76_label, new L1Inst { op = 76, m = "Lbl", s = "m" });
        TInst.Add(Vocab.I77_x_greater_or_equal_than_t, new L1Inst { op = 77, m = "x≥t", s = "b" });
        TInst.Add(Vocab.I78_sigma_plus, new L1Inst { op = 78, m = "Σ+", s = "a", i = true });
        TInst.Add(Vocab.I79_average, new L1Inst { op = 79, m = "x̄", s = "a", i = true });
        TInst.Add(Vocab.I80_grades, new L1Inst { op = 80, m = "Grad", s = "a" });
        TInst.Add(Vocab.I81_reset, new L1Inst { op = 81, m = "RST", s = "a" });
        TInst.Add(Vocab.I82_hir, new L1Inst { op = 82, m = "HIR", s = "d" });
        TInst.Add(Vocab.I83_goto_indirect, new L1Inst { op = 83, m = "GO*", s = "i" });
        TInst.Add(Vocab.I84_operation_indirect, new L1Inst { op = 84, m = "Op*", s = "i" });
        TInst.Add(Vocab.I85_add, new L1Inst { op = 85, m = "+", s = "a" });
        TInst.Add(Vocab.I86_set_flag, new L1Inst { op = 86, m = "STF", s = "di", i = true });
        TInst.Add(Vocab.I87_if_flag, new L1Inst { op = 87, m = "IFF", s = "idb", i = true });
        TInst.Add(Vocab.I88_dms, new L1Inst { op = 88, m = "D.MS", s = "a", i = true });
        TInst.Add(Vocab.I89_pi, new L1Inst { op = 89, m = "π", s = "a" });
        TInst.Add(Vocab.I90_list, new L1Inst { op = 90, m = "List", s = "a", i = true });
        TInst.Add(Vocab.I91_run_stop, new L1Inst { op = 91, m = "R/S", s = "a" });
        TInst.Add(Vocab.I92_return, new L1Inst { op = 92, m = "RTN", s = "a" });
        TInst.Add(Vocab.I93_dot, new L1Inst { op = 93, m = ".", s = "a" });
        TInst.Add(Vocab.I94_change_sign, new L1Inst { op = 94, m = "+/-", s = "a" });
        TInst.Add(Vocab.I95_equals, new L1Inst { op = 95, m = "=", s = "a" });
        TInst.Add(Vocab.I96_write, new L1Inst { op = 96, m = "Write", s = "a", i = true });
        TInst.Add(Vocab.I97_dsz, new L1Inst { op = 97, m = "Dsz", s = "idb", i = true });
        TInst.Add(Vocab.I98_advance, new L1Inst { op = 98, m = "Adv", s = "a" });
        TInst.Add(Vocab.I99_print, new L1Inst { op = 99, m = "Prt", s = "a" });
    }


    public L1Tokenizer(Vocab lexer)
    {
        this.lexer = lexer;
    }

    public IEnumerable<L1Token> EnumerateAllTokens()
    {
        IToken? nextToken = null;
        for (; ; )
        {
            IToken token;
            if (nextToken != null)
            {
                token = nextToken;
                nextToken = null;
            }
            else
                token = lexer.NextToken();

            string symbolicName = lexer.Vocabulary.GetSymbolicName(token.Type);
            string typeName = symbolicName ?? lexer.Vocabulary.GetDisplayName(token.Type);
            //Console.WriteLine($"Type: {typeName,-15} Text: '{token.Text}'");

            switch (token.Type)
            {
                case TokenConstants.EOF:
                    var teof = new L1Eof { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.Eof };
                    yield return teof;
                    yield break;

                case Vocab.WS:
                    // Ignore WS, they are useful to split ambiguous sequences, but we don't need them for analysis
                    break;

                case Vocab.LINE_COMMENT:
                    var tlc = new L1LineComment { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.LineComment };
                    yield return tlc;
                    break;

                case Vocab.PROGRAM_SEPARATOR:
                    var tps = new L1ProgramSeparator { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.ProgramSeparator };
                    yield return tps;
                    break;

                case Vocab.D1:      // SyntaxCategory will be determined later
                    var td1 = new L1D1 { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.Unknown };
                    yield return td1;
                    break;

                case Vocab.D2:      // SyntaxCategory will be determined later
                    var td2 = new L1D2 { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.Unknown };
                    yield return td2;
                    break;

                case Vocab.A3:
                    var ta3 = new L1A3 { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.DirectAddress };
                    yield return ta3;
                    break;

                case Vocab.NUM:
                    var tnum = new L1Num { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.Number };
                    yield return tnum;
                    break;

                case Vocab.TAG:
                    var ttag = new L1Tag { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.Tag };
                    yield return ttag;
                    break;

                case Vocab.COLON:       // Category is not really clear, let's assume Tag for now
                    var tco = new L1Colon() { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.Tag };
                    yield return tco;
                    break;

                case Vocab.INVALID_CHAR:
                    var tic = new L1InvalidToken() { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.Invalid };
                    for (; ; )
                    {
                        nextToken = lexer.NextToken();
                        if (nextToken.Type != Vocab.INVALID_CHAR)
                            break;
                        tic.Tokens.Add(nextToken);
                    }
                    yield return tic;
                    break;

                default:
                    Debug.Assert(symbolicName.StartsWith('I')); // Only instructions should remain
                    Debug.Assert(TInst.ContainsKey(token.Type));
                    var ti = new L1Instruction() { Tokens = new List<IToken> { token }, Cat = SyntaxCategory.Instruction, Inst = TInst[token.Type] };
                    yield return ti;
                    break;
            }
        }
    }
}
