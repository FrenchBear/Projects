// 5th variant of T59 grammar - parser
// Only use ANTLR lexical parsing in this version
//
// 2025-11-22   PV
// 2025-12-01   PV      Added Mean, Sigma, ∑+, y**x, x⇌t and; line comment for ti5x_android
// 2025-12-05   PV      2nd prefix added

lexer grammar Vocab;

options {
    caseInsensitive = true;
}

// White space
WS: [ \t\r\n]+ -> channel(HIDDEN); // Skip whitespace

LINE_COMMENT: ('//'|';') ~[\r\n]*;

PROGRAM_SEPARATOR: 'END';

fragment Second: '2nd' [ \t\r\n]*;

// Instructions (1-digit are covered by D1 -> number)
// Generated by Excel
// -------------------------------

I10_e_prime: 'E\'' | 'E´' | Second 'E';
I11_a: 'A';
I12_b: 'B';
I13_c: 'C';
I14_d: 'D';
I15_e: 'E';
I16_a_prime: 'A\'' | 'A´' | Second 'A';
I17_b_prime: 'B\'' | 'B´' | Second 'B';
I18_c_prime: 'C\'' | 'C´' | Second 'C';
I19_d_prime: 'D\'' | 'D´' | Second 'D';
I20_2nd_clear: 'CLR\'' | 'CLR´' | Second 'CLR';

I22_invert: 'INV';
I23_ln: 'lnx';
I24_correct_entry: 'CE';
I25_clear: 'CLR';

I27_2nd_invert: 'INV\'' | 'INV´' | Second 'INV';
I28_log: 'log' | Second 'lnx';
I29_clear_program: 'CP' | Second 'CE';
I30_tan: 'tan' | Second '1/x';

I32_exchange_x_and_t: 'x↔t' | 'x⇄t' | 'x≷t' | 'x<>t' | 'x/t' | 'x-t' | 'x~t' | 'x⇌t' | 'x%t';
I33_square: 'x²' | 'x^2' | 'X2';
I34_square_root: '√' | '√x' | 'SQRT' | 'SQR';
I35_reciprocal: '1/x';
I36_program: 'Pgm';
I37_polar_to_rectangular: 'P→R' | 'P->R' | 'P/R' | 'P-R' | Second 'x↔t' | Second 'x⇄t' | Second 'x≷t' | Second 'x<>t' | Second 'x/t' | Second 'x-t' | Second 'x~t' | Second 'x⇌t' | Second 'x%t';
I38_sin: 'sin' | Second 'x²' | Second 'x^2' | Second 'X2';
I39_cos: 'cos' | Second '√' | Second '√x' | Second 'SQRT' | Second 'SQR';
I40_indirect: 'Ind' | Second 'yˣ' | Second '^' | Second 'y^x' | Second 'YX' | Second '**' | Second 'y**x' | Second 'pow';

I42_store: 'STO';
I43_recall: 'RCL';
I44_sum: 'SUM';
I45_power: 'yˣ' | '^' | 'y^x' | 'YX' | '**' | 'y**x' | 'pow';

I47_clear_memory: 'CMs' | Second 'STO';
I48_exchange: 'Exc' | Second 'RCL';
I49_product: 'Prd' | Second 'SUM';
I50_absolute: '|x|' | 'ABS' | 'IXI' | Second '÷' | Second '/';

I52_exponent: 'EE';
I53_left_parenthesis: '(';
I54_right_parenthesis: ')';
I55_divide: '÷' | '/';

I57_engineering: 'Eng' | Second 'EE';
I58_fix: 'Fix' | Second '(';
I59_integer: 'Int' | Second ')';
I60_degrees: 'Deg' | Second '×' | Second '*';
I61_goto: 'GTO';
I62_program_indirect: 'PG*';
I63_exchange_indirect: 'EX*';
I64_product_indirect: 'PD*';
I65_multiply: '×' | '*';
I66_pause: 'Pause' | 'PAU' | Second 'GTO';
I67_x_equals_t: 'x=t' | 'EQ';
I68_nop: 'Nop';
I69_operation: 'Op';
I70_radians: 'Rad' | Second '-';
I71_subroutine: 'SBR';
I72_store_indirect: 'ST*';
I73_recall_indirect: 'RC*';
I74_sum_indirect: 'SM*';
I75_subtract: '-';
I76_label: 'Lbl' | Second 'SBR';
I77_x_greater_or_equal_than_t: 'x≥t' | 'x>=t' | 'GE';
I78_sigma_plus: 'Σ+' | '∑+' | 'SIG+' | 'STA' | 'Sigma' | 'S+';
I79_average: 'x̄' | 'AVG' | 'AVR' | 'Mean' | 'mean(x)';
I80_grades: 'Grad' | 'GRD' | Second '+';
I81_reset: 'RST';
I82_hir: 'HIR';
I83_goto_indirect: 'GO*';
I84_operation_indirect: 'Op*';
I85_add: '+';
I86_set_flag: 'STF' | 'stflg' | Second 'RST';
I87_if_flag: 'IFF' | 'ifflg';
I88_dms: 'D.MS' | 'DMS';
I89_pi: 'π' | 'PI';
I90_list: 'List' | 'LST' | Second '=';
I91_run_stop: 'R/S';
I92_return: 'RTN';
I93_dot: '.';
I94_change_sign: '+/-';
I95_equals: '=';
I96_write: 'Write' | 'Wrt' | Second 'R/S';
I97_dsz: 'Dsz';
I98_advance: 'Adv' | Second '.';
I99_print: 'Prt' | Second '+/-';

I2223_e_power_x: 'eˣ' | 'e^x';
I2228_10_power_x: '10ˣ' | '10^x';
I6740_x_equals_t_indirect: 'EQ*';
I7740_x_greater_or_equal_than_t_indirect: 'GE*';


// -------------------------------

// Digits and addresses
D1: [0-9];
D2: [0-9][0-9];
A3: [0-9][0-9][0-9];
//A4: '0'[0-9] [ \t\r\n]* [0-9][0-9];       // Moved to parser to avoid DSZ 05 25 issue, using dynamic recognition
NUM: '-'? (([0-9]+ ('.' [0-9]*)?) | ('.' [0-9]+)) ('E' ('+'|'-')? [0-9]+)?;            // Standard scientific number

// Extra labels (case insensitive, so includes a-z)
TAG: '@' [A-Z_][A-Z0-9_]*;
COLON: ':';

// Add a catch-all rule so the lexer won't raise errors. L1Tokenizer winn group consecutive INVALID_CHAR into L1InvalidToken
INVALID_CHAR: .;
